<!DOCTYPE HTML>
<!--
	Prologue by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Mattéo Clémot</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<link rel="icon" type="image/png" href="icon.png">
		<meta name="robots" content="noindex, nofollow" />
	</head>
	<body class="is-preload">

		<!-- Header -->
			<div id="header">

				<div class="top">

					<!-- Logo -->
						<div id="logo">
							<a href="index.html">
								<span class="image"><img src="icon.png" alt="" width=64 height=64 /></span>
								<h1 id="title">Mattéo Clémot</h1>
								<p>Student in Computer Science</p>
							</a>
						</div>

					<!-- Nav -->
						<nav id="nav">
							<ul>
								<li><a href="index.html" id="top-link"><span class="icon solid fa-home">Home</span></a></li>
								<li><div style='background-color: #3a3a3a; min-height: 1px; margin-right: 10%; margin-left: 10%;'></div></li>
								<li><a href="glsl.html" id="code-link"><span class="icon solid fa-code">Fractals</span></a></li>
							</ul>
						</nav>

				</div>

				<div class="bottom">

					<!-- Social Icons -->
						<ul class="icons">
							<li><a href="https://github.com/MClemot" class="icon brands fa-github"><span class="label">Github</span></a></li>
							<li><a href="mailto:matteo.clemot@ens-lyon.fr" class="icon solid fa-envelope"><span class="label">Email</span></a></li>
							<li><a href="https://orcid.org/0009-0000-2524-0244" class="icon brands fa-orcid"><span class="label">Orcid</span></a></li>
						</ul>

				</div>

			</div>

		<!-- Main -->
			<div id="main">
				<!-- Home -->
					<section id="home" class="two">
						<header>
							<h2>Quaternionic Julia set sphere-tracing rendering</h2>
						</header>
						<div class="container">
							<div class="row">           
					            <div class="col-3 col-12-mobile" id="control">
						            <table>
									<col width = "50%">
									<col width = "50%">
									<tr>
										<td><span>\(q_x\): </span><span id="label_x">-1.0</span></div><div><input type="range" min="-2" max="2" step=".1" value="-1." class="slider" id="slider_x" style="width: 125%;"></div></td>
										<td><span>\(q_y\): </span><span id="label_y">0.2</span></div><div><input type="range" min="-2" max="2" step=".1" value="0.2" class="slider" id="slider_y" style="width: 125%;"></div></td>
									</tr><tr>
										<td><span>\(q_z\): </span><span id="label_z">0.0</span></div><div><input type="range" min="-2" max="2" step=".1" value="0.0" class="slider" id="slider_z" style="width: 125%;"></td>
										<td><span>\(q_w\): </span><span id="label_w">0.0</span></div><div><input type="range" min="-2" max="2" step=".1" value="0.0" class="slider" id="slider_w" style="width: 125%;"></div></td>
									</tr><tr>
										<td><div><span>k: </span><input id="number_k"   min=".2" step=".1" type="number" value=".8" style="width: 125%;"></div></td>
										<td><div><span>e: </span><input id="number_eps" step=".0001" type="number" value=".002" style="width: 125%;"></div></td>
									</tr>
									<tr>
										<td><div><span style="font-size:15pt;">Diffuse </span><input type="color" value="#ffffff" class="colorpicker" id="color_gra"></div></td>
										<td><div><span style="font-size:15pt;">Background </span><input type="color" value="#770000" class="colorpicker" id="color_grb"></div></td>
									</tr>
									<tr>
										<td><div><span style="font-size:15pt;">Light \(\theta\): </span><span id="label_th_l" style="font-size:15pt;">180</span></div><div><input  min="0"  max="360" step="1" type="range" value="180" class="slider" id="slider_th_l" style="width: 125%;"></div></td>
										<td><div><span style="font-size:15pt;">Light \(\phi\): </span><span id="label_phi_l" style="font-size:15pt;">45</span></div><div><input  min="-90"  max="90" step="1" type="range" value="45" class="slider" id="slider_phi_l" style="width: 125%;"></div></td>
									</tr>
									</table>
						            <label>Shadows </label><input type="checkbox" id="check_shadows" style="appearance: checkbox;">
					            </div>
					            
					            <div class="col-9 col-12-mobile">
					                <div id="container"></div>
					            </div>
					        </div>
					    </div>
					</section>
			</div>

		<!-- Footer -->
			<div id="footer">

				<!-- Copyright -->
					<ul class="copyright">
						<li>&copy; Mattéo Clémot. All rights reserved.</li><li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
					</ul>

			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

			<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
			<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>		

			<script src="three.min.js"></script>
	        <script id="fragmentShader" type="x-shader/x-fragment">
	            uniform float camx;
	            uniform float camy;
	            uniform float r;
	            uniform float phi;
	            uniform float th;
	            uniform vec4 c;
	            uniform vec3 light;
	            uniform int shadows;

	            /*const float k   = .8;
	            const float eps = .002;*/
	            const float d = .000001;
	            //const float d = .0001;
	            const float l = 100.;

	            uniform float k;
	            uniform float eps;

	            uniform vec3 gra;
	            uniform vec3 grb;
	            const vec3 amb = vec3(.6,.8,1.);

	            const float f=2.;
	            //const vec3 light = vec3(100.,100.,100.);
	            
	            vec3 er   = vec3(sin(th)*cos(phi), sin(th)*sin(phi), cos(th));
	            vec3 eth  = vec3(cos(th)*cos(phi), cos(th)*sin(phi), -sin(th));
	            vec3 ephi = vec3(-sin(phi), cos(phi), 0.);
	            
	            vec3 focus = (r+f)*er;
	            
	            /*vec4 mul(vec4 q1, vec4 q2) {
	                return vec4(q1.x*q2.x - q1.y*q2.y - q1.z*q2.z - q1.w*q2.w,
	                            q1.x*q2.y + q1.y*q2.x + q1.z*q2.w - q1.w*q2.z,
	                            q1.x*q2.z + q1.z*q2.x - q1.y*q2.w + q1.w*q2.y,
	                            q1.x*q2.w + q1.w*q2.x + q1.y*q2.z - q1.z*q2.y);
	            }*/

	            vec4 mul(vec4 q1, vec4 q2) {
	                return vec4(q1.x*q2.x - dot(q1.yzw, q2.yzw), q1.x*q2.yzw + q2.x*q1.yzw + cross(q1.yzw, q2.yzw));
	            }
	            
	            /*vec4 sqr(vec4 q) {
	                return vec4(q.x*q.x - q.y*q.y - q.z*q.z - q.w*q.w, 2.*q.x*q.yzw);
	            }*/

	            vec4 sqr(vec4 q) {
	                return vec4(q.x*q.x - dot(q.yzw,q.yzw), 2.*q.x*q.yzw);
	            }

	            float estimator(vec3 pos) {
	                vec4 z = vec4(pos, 0.);
	                vec4 dz = vec4(1., 0., 0., 0.);
	                /*while(length(z) < 10.) {
	                    dz = 2.*mul(z,dz);
	                    z = sqr(z) + c;
	                }*/
	                for(int j=0; j<10000; ++j) {
	                    if(dot(z,z) >= 100.)
	                        break;
	                    dz = 2.*mul(z,dz);
	                    z = sqr(z) + c;
	                }

	                return .5*length(z)*log(length(z))/length(dz);
	            }
	            
	            vec3 normal_estimator_hack(vec3 pos) {
	                vec4 q = vec4(pos, 0.);
	                vec4 qx1 = q - vec4(d, 0, 0, 0);
	                vec4 qx2 = q + vec4(d, 0, 0, 0);
	                vec4 qy1 = q - vec4(0, d, 0, 0);
	                vec4 qy2 = q + vec4(0, d, 0, 0);
	                vec4 qz1 = q - vec4(0, 0, d, 0);
	                vec4 qz2 = q + vec4(0, 0, d, 0);
	                for(int i=0; i<25; i++) {
	                    if(dot(qx1,qx1)>l||dot(qx2,qx2)>l||dot(qy1,qy1)>l||dot(qy2,qy2)>l||dot(qz1,qz1)>l||dot(qz2,qz2)>l)
	                        break;
	                    qx1 = sqr(qx1)+c;
	                    qx2 = sqr(qx2)+c;
	                    qy1 = sqr(qy1)+c;
	                    qy2 = sqr(qy2)+c;
	                    qz1 = sqr(qz1)+c;
	                    qz2 = sqr(qz2)+c;
	                }
	                vec3 N = vec3(length(qx2)-length(qx1), length(qy2)-length(qy1), length(qz2)-length(qz1));
	                //vec3 N = vec3(-length(qx1), -length(qy1), -length(qz1));
	                return normalize(N);
	            }

	            vec3 normal_estimator_gradient(vec3 pos) {
	                vec3 N = vec3(estimator(pos + vec3(d, 0., 0.)) - estimator(pos - vec3(d, 0., 0.)),
	                              estimator(pos + vec3(0., d, 0.)) - estimator(pos - vec3(0., d, 0.)),
	                              estimator(pos + vec3(0., 0., d)) - estimator(pos - vec3(0., 0., d)));
	                return normalize(N);
	            }
	            
	            void main(void)
	            {            
	                vec3 proj  = r*er + (2.*float(gl_FragCoord.x)-camx)/camx*ephi + (2.*float(gl_FragCoord.y)-camy)/camx*eth;
	                vec3 ray = proj - focus;
	                ray = normalize(ray);
	            
	                vec3 p = focus;
	                float d = 2.*eps;
	               	float prev_d = d;

	                /*while(d >= eps && length(p) <= r+f+.1) {
	                    d = estimator(p);
	                    p += k*d*ray;
	                }*/

	                for(int j=0; j<10000; ++j) {
	                    if(d < eps || length(p) > r+f+.1)
	                        break;
	                    prev_d = d;
	                    d = estimator(p);
	                    p += k*d*ray;
	                }
	            
	                if(d < eps) {
	                	if(shadows==1) {
							vec3 shadow_ray = normalize(light - p);
		                	vec3 shadow_p = p - k*(d+prev_d)*ray;
		                    d = 2.*eps;
			                for(int j=0; j<10000; ++j) {
			                    if(d < eps || length(shadow_p) > r+f+.1)
			                        break;
			                    d = estimator(shadow_p);
			                    shadow_p += k*d*shadow_ray;
			                }
			                if(d < eps) {
			                	gl_FragColor = vec4(0.,0.,0.,1.);
			            	}
			                else {
				                vec3 normal = normal_estimator_hack(p);
			                    float i = dot(normal, normalize(light));
			                    
			                    gl_FragColor = vec4(.2*amb+.8*i*gra, 1.);
			           		}
	                	}
	                	else{
							vec3 normal = normal_estimator_hack(p);
			                float i = dot(normal, normalize(light));
			                    
			                gl_FragColor = vec4(.2*amb+.8*i*gra, 1.);
	                	}
	                }
	                else
	                    gl_FragColor = vec4(grb, 1.);
	                //gl_FragColor = vec4(0.,1.,0.,1.);
	            }
	        </script>
	        <script>
	            var container;
	            var camera, scene, renderer;
	            var uniforms;
	            var mouseX, mouseY;
	            var startX, startY, mode, zoomX, zoomY;
	            var propX, propY;
	    
	            init();
	            animate();
	    
	            var R, PHI, TH, C, uniforms, t;

	            function spherical(phi,th) {
	            	phi_r = phi * 3.141593 / 180.;
	            	th_r = th * 3.141593 / 180.;
	            	v = new THREE.Vector3(100.*Math.cos(phi_r)*Math.cos(th_r), 100.*Math.cos(phi_r)*Math.sin(th_r), 100.*Math.sin(phi_r));
	            	return v;
	            }
	    
	            function init() {
	                t = 0;
	                container = document.getElementById( 'container' );
	    
	                camera = new THREE.Camera();
	                camera.position.z = 1;
	    
	                scene = new THREE.Scene();
	    
	                var geometry = new THREE.PlaneBufferGeometry( 2, 2 );
	    
	                if (window.innerWidth > window.innerHeight) {
	                	propX = .55;
	                	propY = .7;
	                }
	                else {
	                	propX = .9;
	                	propY = .6;
	                }

	                var estimX = propX*window.innerWidth*window.devicePixelRatio;
	                var estimY = propY*window.innerHeight*window.devicePixelRatio;

	                document.getElementById('check_shadows').checked = true;

	                C = new THREE.Vector4(-1.,.2,.0,.0);
	                GRA = new THREE.Vector3(1.,1.,1.);
	                GRB = new THREE.Vector3(.5,0.,0.);

	                LIGHT = spherical(45.,180.);
	    
	                uniforms = {
	                    camx : { type: "f", value: estimX },
	                    camy : { type: "f", value: estimY },
	                    r : { type: "f", value: 3. },
	                    phi : { type: "f", value: 0. },
	                    th : { type: "f", value: -1. },
	                    c : { type: "vec4", value: C },
	                    k : { type: "f", value: .8 },
	                    eps : { type: "f", value: 0.002 },
	                    gra : { type: "vec3", value: GRA },
	                    grb : { type: "vec3", value: GRB },
	                    light : { type: "vec3", value: LIGHT },
	                    shadows: { type: "int", value: 1 }
	                };
	    
	                var material = new THREE.ShaderMaterial( {
	                    uniforms: uniforms,
	                    fragmentShader: document.getElementById( 'fragmentShader' ).textContent
	                } );
	    
	                var mesh = new THREE.Mesh( geometry, material );
	                scene.add( mesh );
	    
	                renderer = new THREE.WebGLRenderer();
	                renderer.setPixelRatio( window.devicePixelRatio );
	    
	                container.appendChild( renderer.domElement );
	    
	                onWindowResize();
	                window.addEventListener( 'resize', onWindowResize, false );
	                container.addEventListener( 'wheel', onWheelMoved );
	    
	                function update(e) {
	                    mouseX = e.pageX;
	                    mouseY = e.pageY;
	                }
	    
	                container.onmousemove = update;
	    
	                document.onmouseup = function() {
	                    container.onmousemove = update;
	                }
	    
	                container.onmousedown = function() {
	                    container.onmousemove = function(e){

	                        uniforms.phi.value += .01*(e.pageX-mouseX);
	                        uniforms.th.value += .01*(e.pageY-mouseY);
	                        update(e);
	                    }
	                }

	                container.addEventListener('touchstart', onTouchStart, false);
	                container.addEventListener('touchmove', onTouchMove, false);
	                container.addEventListener('touchend', onTouchStart, false);
	    
	                document.getElementById('slider_x').oninput = function() {
	                    C.setX(this.value);
	                    document.getElementById('label_x').innerHTML = this.value;
	                }
	                document.getElementById('slider_y').oninput = function() {
	                    C.setY(this.value);
	                    document.getElementById('label_y').innerHTML = this.value;
	                }
	                document.getElementById('slider_z').oninput = function() {
	                    C.setZ(this.value);
	                    document.getElementById('label_z').innerHTML = this.value;
	                }
	                document.getElementById('slider_w').oninput = function() {
	                    C.setW(this.value);
	                    document.getElementById('label_w').innerHTML = this.value;
	                }
	                document.getElementById('slider_phi_l').oninput = function() {
	                	LIGHT = spherical(this.value, document.getElementById('slider_th_l').value)
	                	uniforms.light.value = LIGHT;
	                    document.getElementById('label_phi_l').innerHTML = this.value;
	                }
	                document.getElementById('slider_th_l').oninput = function() {
	                	LIGHT = spherical(document.getElementById('slider_phi_l').value, this.value)
	                	uniforms.light.value = LIGHT;
	                    document.getElementById('label_th_l').innerHTML = this.value;
	                }
	                document.getElementById('check_shadows').oninput = function() {
	                	if(this.checked)
	                		uniforms.shadows.value = 1;
	                	else
	                		uniforms.shadows.value = 0;
	                }

	                document.getElementById('number_k').oninput = function() { uniforms.k.value = this.value; }
	                document.getElementById('number_eps').oninput = function() { uniforms.eps.value = this.value; }

	                document.getElementById('color_gra').oninput = function() {
	                     var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(this.value);
	                     GRA = new THREE.Vector3(parseInt(result[1], 16)/255, parseInt(result[2], 16)/255, parseInt(result[3], 16)/255);
	                     uniforms.gra.value = GRA;
	                }
	                document.getElementById('color_grb').oninput = function() {
	                     var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(this.value);
	                     GRB = new THREE.Vector3(parseInt(result[1], 16)/255, parseInt(result[2], 16)/255, parseInt(result[3], 16)/255);
	                     uniforms.grb.value = GRB;
	                }
	            }
	    
	            function onWheelMoved( event ) {
	                if(event.deltaY > 0)
	                    uniforms.r.value *= 1.1;
	                else
	                    uniforms.r.value /= 1.1;
	                event.preventDefault();
    				event.stopPropagation();
	            }

	            function onTouchStart(e) {
	                if(e.touches.length == 1) {
	                    mode = 1
	                    var touchobj = e.touches[0];
	                    startX = parseInt(touchobj.clientX);
	                    startY = parseInt(touchobj.clientY);
	                    e.preventDefault();
	                }
	                else if (e.touches.length == 2) {
	                    mode = 2
	                    var touchobj0 = e.touches[0];
	                    var touchobj1 = e.touches[1];
	                    var X0 = parseInt(touchobj0.clientX);
	                    var Y0 = parseInt(touchobj0.clientY);
	                    var X1 = parseInt(touchobj1.clientX);
	                    var Y1 = parseInt(touchobj1.clientY);
	                    startX = Math.sqrt((X0-X1)*(X0-X1)+(Y0-Y1)*(Y0-Y1));
	                    e.preventDefault();
	                }
	            }
	    
	            function onTouchMove(e) {
	                if(e.touches.length == 1) {
	                    if(mode == 2)
	                        onTouchStart(e);
	                    else {
	                        var touchobj = e.changedTouches[0];
	                        uniforms.phi.value += .01*(parseInt(touchobj.clientX) - startX);
	                        uniforms.th.value += .01*(parseInt(touchobj.clientY) - startY);
	                        startX = parseInt(touchobj.clientX);
	                        startY = parseInt(touchobj.clientY);
	                        uniforms.ox.value = OX;
	                        uniforms.oy.value = OY;
	                        e.preventDefault();
	                    }
	                }
	                else if (e.touches.length == 2) {
	                    var touchobj0 = e.touches[0];
	                    var touchobj1 = e.touches[1];
	                    var X0 = parseInt(touchobj0.clientX);
	                    var Y0 = parseInt(touchobj0.clientY);
	                    var X1 = parseInt(touchobj1.clientX);
	                    var Y1 = parseInt(touchobj1.clientY);
	                    var N = Math.sqrt((X0-X1)*(X0-X1)+(Y0-Y1)*(Y0-Y1));
	                    uniforms.r.value *= startX/N;
	                    startX = N;
	                    e.preventDefault();
	                }
	            }
	    
	            function onWindowResize( event ) {
	                renderer.setSize( propX*window.innerWidth, propY*window.innerHeight );
	            }
	    
	            function animate() {
	                requestAnimationFrame( animate );
	                render();
	            }
	    
	            function render() {
	                renderer.render( scene, camera );
	            }
	        </script>
	</body>
</html>